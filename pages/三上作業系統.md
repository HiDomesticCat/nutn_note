public:: true

- ## operating system structure
	- multiprogramming
		- job scheduling
	- timesharing (multitasking)
		- virtual memory
	- spooling (simultaneous peripheral operations on-line)
		- 關於慢速裝置如何與計算機主機交換資訊的一種技術
		- 又稱 排隊轉儲技術
	- Interrupt driven (hardware and software)
		- hardware error
		- software interrupt (exception or trap)
			- software error
			- other process problems include infinite loop
	- Dual-mod
		- user mode and kernel mode
		- mode bit
			- system call
	- multi-mod
		- virtual machine manager (VMM) mode for guest VMs
- Transition from user to kernel mode
- process management
	- program is a passive entity, process is an active entity
- protection and security
- Virtualization
	- emulation
		- i.e PowerPC to x86
	- virtualization
		- consider VirtualBox running WinXP guest, each running application, all on native WinXP host OS
		- VMM provides virtualization services
		- 虛擬機（VM）與容器（Container）
			- VM
				- 將硬體資源抽象化後可自由分配給上層的虛擬機使用
				- 屬於作業系統層級虛擬化技術
				- hypervisor 負責管理與分配硬體資源
				- DVM 與 JVM
					- Dalvik Virtual Machine（DVM）：基於寄存器（Register-Based）的指令集架構
					- Java Virtual Machine（JVM）：基於堆疊（Stack-Based）的指令集架構
			- 容器
				- 讓整個軟體系統的執行環境可以搬遷
				- 以應用程式為單位的虛擬化技術，應用程式與其相依性資源會被封裝在容器中，使其可以重複利用與搬遷容器間彼此獨立運行，互不干擾
		- cloud computing
			- public cloud
			- private cloud
			- hybrid cloud
			- Software as a Service (SaaS) 提供應用程式工使用
			- Platform as a Service (PaaS) 提供開發應用程式的環境
			- Infrastructure as a Service (IaaS) 可在上面架設開發應用程式的環境
- Operation Structure
	- operation system interface
		- CLI
		- system calls
			- application programming interface (API)
			- Win32 API、POSIX API、JAVA API
			- types
				- process control
				- file management
				- device management
				- information maintenance
				- communications
				- protection
		- system program
			- file modification
			- programming-language support
			- program load and execution
			- communications
			- background services
				- lunch at boot time
				- provide facilities
				- run in user context not kernel context
- operating system design and implementation
	- important principle to separate
		- policy
		- mech
	- layered approach
	- micro-kernel system structure
		- communication takes place between user modules using message passing
		- detriments
			- performance overhead
	- modules
		- loadable kernel modules
	- hybrid system
		- most modern operating system are actually not one pure module
- operating system generation
	- SYSGEN
- ## Process Concept
	- multiple parts
		- the program code, also called text section
		- current activity including program counter, processor registers
		- stack containing temporary data
			- function parameters, return addresses, local variables
		- Data section containing
	- Process Control Block (PCB)
		- process state
		- program counter
		- CPU registers
		- CPU scheduling information
		- memory-management information
		- accounting infomation
		- I/O status information
	- Threads
		- Multiple locations can execute at once
	- Process Scheduling
		- maintains scheduling queues of processes
			- Job queue
			- Ready queue
			- Device queue
			- Processes migrate among the various queues
		- process can be described as ether
			- I/O-bound process
			- CPU-bound process
	- Context Switch
	- process creation
		- parent process create children process, which, in tum create other processes, forming a tree of processes
	- process termination
		- cascading termination
	- interprocess communication (IPC)
		- two models of IPC
			- shared memory
			- message passing
		- producer-consumer problem
			- unbounded-buffer
			- bounded-buffer
	- Remote Procedure Calls (Cont.)
	- pipes
		- ordinary pipes
		- named pipes
- ## muti-thread
	- motivation
	- benefits
- ## Multicore Programming
	- types of parallelism
		- Data prarllelism
			- same operation on each
		- Task parallelism
			- CPUs have cores as well as hardware threads
	- Amdahl's Law
		- N processing
			- $speedup /leq \ frac{1}{S + \frac{(1-S)}{N}}$$
	- 概述與動機
		- 多執行序（Threads）：現代應用程式的核心，允許程式在單一進程中執行多個任務
		- 多工處理架構（Multiprocessor Architectures）：可提昇並行處理的效率，而執行序的創建與切換鄉對於進程更輕量，具有更高的經濟性
	- 執行序的優勢
		- 反應速度（Responsiveness）：允許應用程式在某些部份受阻的情況下，仍能維持互動性
		- 資源共享（Resource Sharing）：執行序可共享相同進程的記憶體和資源，無需額外的通訊機制
		- 經濟性（Economy）：創建執行序的成本低於創建進程，並且執行序切換的負擔也小於進程切換
		- 可擴充性（Scalability）：多執行序可在多核心系統中運行，並行性隨著處理器核心數量的增加而提昇
	- 多核心程式設計（Multicore Programming）
		- 並行性（Parallelism）：系統可同時執行多項任務（如：資料平行化、任務平行化），特別適合多核心系統
		- 併發性（Concurrency）：即使在單核心系統中，仍能透過調度程式管理多個任務的進行
	- 執行序模型（Multithreading Models）
		- 多對一（Many-to-One）：多個使用者層級的執行序映射到單一的核心執行序，所有執行序共享一個資源，一旦其中一個阻塞則其他執行序也受阻
		- 一對一（One-to-One）：每個使用者層級的執行序都有一個對應的核心執行序，能提供更高的並行性，但會有更多的資源開銷
		- 多對多（Many-to-Many）：多個使用者執行序映射到多個核心執行序，操作系統可根據需求創建適量的核心執行序，兼顧效率和靈活性
	- 執行序庫（Thread Libraries）
		- POSIX Pthreads (UNIX系統)
		- Windows Threads
		- Java Threads
		- 這些庫為執行緒的創建和管理提供API，且可透過不同的方式實現（如完全在使用者空間或由操作系統核心支援）。
	- 隱式多執行序（Implicit Threading）
		- 由於顯式多執行序程式設計的複雜性，隱式多執行序越來越受到重視
		- 包括
			- 執行序池（Thread Pools）
			- OpenMP
			- Grand Central Dispatch（GCP）：Apple 針對多核心硬體開發的技術，用於管理並行執行的細節
	- 執行序管理中的問題
		- `fork()` 和 `exec()`：`fork()`創建的子進程是否應包含所有父進程的執行序是需要可慮的
		- 訊號處理（Signal Handling）：在 UNIX 系統中，訊號用於通知進程某些事件的發生，多執行序環境下，訊號處理可以根據需求分配到不同的執行序中
		- 執行序取消（Thread Cancellation）：分為分同步取消（Asynchronous Cancellation）和延遲取消（Deferred Cancellation），前者立即終止執行序，後者則允許執行序定期檢查是否應被取消
	- 執行序的操作系統支援
		- Windows 和 Linux 都支援多執行序
		- Windows 實現了一對一的映射，並在每個執行序中包含執行的 ID、暫存器集、用戶堆疊與核心堆疊等資訊
		- Linux 透過 `clone()` 系統調用創建新執行序，並允許父子進程共享地址空間
-
- ## User Threads and Kernel Threads
- ## Thread Libraries
	- provides programmer with API for creating
	- Pthreads
		- provided either as user-level or kernal_level
- Thread Pool
- ## Process Scheduling
	- 基本概念
		- 程序排程是在多工作業系統中的核心機制
		- CPU 的執行會交替於 CPU 週期與 I/O 等待中，已達到最大的 CPU 利用率
		- 程序的突發時間分佈：I/O 密集程序通成是 CPU 突發時間（CPU burst）短，而 CPU 密集程序的突發時間則較長，選擇合適的排程演算法實需考慮突發分佈情形
	- CPU 排程器
		- CPU Scheduler：從記憶體已就緒的程序中選擇一個執行
		- 排程決策時機（Nonpreemptive 或 Cooperative）
			- 從執行狀態轉為等待狀態
			  logseq.order-list-type:: number
			- 從執行狀態轉為就緒狀態
			  logseq.order-list-type:: number
			- 從等待狀態轉為就緒狀態
			  logseq.order-list-type:: number
			- 終止
			  logseq.order-list-type:: number
		- 排程模式
			- 非搶佔模式（Nonpreemptive）或合作模式（Cooperative）：程序獲得 CPU 後保持執行，直到其終止或進入等待狀態
			- 搶佔式（Preemptive）：允許系統隨時中止當前程序，將 CPU 分配給其他程序
		- 分配器（Dispatcher）
			- 操作系統中負責將 CPU 從當前運行的程序切換到下一個被選中程序的模怎
			- 功能
				- 上下文切換（Switching Context）：保存當前程序狀態，並加載下一個程序的狀態
				- 切換用戶模式與核心模式：在程序間切換時，負責核心模式與用戶模式之間的轉換
				- 跳轉到正確的位置：將 CPU 設置為指向即將執行程序的指令，以確保程序從正確位置繼續執行
			- 分派延遲（Dispatch Latency）
				- 從當前程序終止或被中止到下一個程序開始執行之間所需的時間
				- 影響因素：上下文切換的複雜度、程序數量、內核的管理開銷
				- 搶佔性系統：在搶佔式排程系統中，分派延遲可能會對系統的實時性和反應時間產生影響，因此系統會盡可能優化這部份的延遲
	- 時間分割系統（Time-Sharing System）
		- 一種多工處理系統，允許多個用戶同時使用一台計算機資源
		- 將 CPU 時間分成若干小段（即「時間片」），並將這些時間片輪流分配給各個程序，以便所有程序都能在一段時間內得到執行
		- 這種分配方式的目的是實現多個程序的 並發執行 和 快速響應。
	- 排程準則
		- CPU 使用率（CPU utilization）：保持 CPU 忙碌的時間最大化
		- 吞吐量（Throughput）：單位時間內完成的程序數
		- 週轉時間（Turnaround time）：程序從提交到完成的總時間
		- 等待時間（Waiting time）：程序在就緒隊列中等待的時間
		- 回應時間（Response time）：從程序提交到產生首次回應的時間，適用於時間分割系統
		- 最佳化目標（通常希望最大化 CPU 使用率和吞吐量，並最小化週轉、等待和回應時間）
	- 排程演算法
		- 先來先服務（First-Come, First-Served Scheduling; FCFS）：根據到達順序排程，存在「護航效應」，及短程序可能排在長程序之後
		- 最短作業優先（Shortest-Job-First Scheduling; SJF）：選擇 CPU 突發時間最短的程序，具有最低平均等待時間的特性
			- 搶佔式 SJF：稱為剩餘時間最短優先
		- 優先權排程（Priority Scheduling）：依據程序優先權決定 CPU 分配順序，可能導致優先權程序「飢餓」
		- 輪詢（Round Robin; RR）：每個程序在指定的時間片內執行，適用於時間分割系統
		- 多層隊列（Multilevel Queue）：將程序分類到不同的隊列中，並根據隊列選擇排程策略
		- 多層反饋隊列（Multievel Feedback Queue）：程序可根據其 CPU 使用情況在不同隊列間移動，以防止 I/O 密集型程序飢餓
	- 多重處理器排程
		- 對稱多處理（Symmetric Multiprocessing; SMP）：每個處理器自我排程，常見於現代作業系統
		- 處理器親和性（Processor Affinity）：避免程序在多處理器間頻繁切換以保留緩存資料
			- 軟性親和性（Soft Affinity）：非強制性保留在同一處理器
			- 硬性親和性（Hard Affinity）：允許程序指定其不可轉移的處理器
	- 多核心處理器
		- 多執行序多核心架構：在同一核心中可運行多執行序，利用多執行序技術在等待 I/O 時切換執行序，以提高處理器效率
		- 粗粒度（Coarse-Grained）與細粒度（Fine-Grained）多執行序：切換成本較低的細粒度執行序切換更頻繁
	- 實例操作系統排程策略
		- Solaris：使用基於優先權的排程，分為多個優先級，並動態調整時間片以適應互動與 CPU 密集型程序
		- Windows XP：採用基於優先權的搶佔式排程，通過優先權調整和時間片延長來增強前景程序的反應時間
		- Linux：採用優先權基礎的搶佔式排程，動態調整優先權以更好地支持互動性程序和多處理器排程
	- 評估演算法
	  id:: 671ebba7-553b-49b3-aefd-b9a461d1faa0
		- 確定性建模：基於給定負載的解析評估方法，提供各演算法的精確比較，但僅適用於靜態負載。
		- 排隊模型：利用到達率和服務率計算平均等待時間等，適合具不確定性的系統。
		- 模擬：透過隨機數生成或真實系統記錄來模擬排程效果，比較演算法效果，精確性較高。
		- 實現：將演算法應用於實際系統中，但成本高昂